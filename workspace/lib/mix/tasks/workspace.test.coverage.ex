defmodule Mix.Tasks.Workspace.Test.Coverage do
  @options_schema Workspace.Cli.options([
                    :workspace_path,
                    :config_path,
                    :project,
                    :affected,
                    :ignore,
                    :verbose
                  ])

  @shortdoc "Runs test coverage on the workspace"

  @moduledoc """
  Run test coverage on the workspace

  You can use it to generate test coverage for one or more projects of the
  workspace. It will take care of finding the `coveradata` files, fixing the
  absolute paths with respect to the workspace root and formatting the
  resutls

      $ mix workspace.test.coverage

  ## Exporting coverage

  This task assumes that `mix test` has been executed with `--cover` and the
  `:export` option under `:test_coverage` set. 

  ## Command line options

  #{CliOpts.docs(@options_schema)}
  """
  use Mix.Task

  @impl true
  def run(args) do
    {:ok, opts} = CliOpts.parse(args, @options_schema)
    %{parsed: opts, args: _args, extra: _extra, invalid: []} = opts

    workspace_path = Keyword.get(opts, :workspace_path, File.cwd!())
    config_path = Keyword.fetch!(opts, :config_path)

    config = Workspace.config(Path.join(workspace_path, config_path))
    workspace = Workspace.new(workspace_path, config)

    paths =
      workspace.projects
      |> Workspace.Cli.filter_projects(opts)
      |> Enum.filter(fn project -> !project.skip end)
      |> Enum.map(&cover_compile_paths/1)

    compile_paths = Enum.map(paths, &elem(&1, 2)) |> List.flatten()

    pid = cover_compile(compile_paths)

    # Silence analyse import messages emitted by cover
    {:ok, string_io} = StringIO.open("")
    Process.group_leader(pid, string_io)
    Mix.shell().info("")

    Enum.each(paths, fn {app, cover_paths, _compile_paths} ->
      import_cover_results(app, cover_paths)
    end)

    calculate_coverage(workspace_path)
    |> List.flatten()
    |> Workspace.Coverage.report(:lcov)
  end

  defp cover_compile_paths(project) do
    test_coverage = project.config[:test_coverage] || []
    output = Keyword.get(test_coverage, :output, "cover")

    compile_path =
      Mix.Project.in_project(
        project.app,
        project.path,
        fn _mixfile ->
          Mix.Project.compile_path()
        end
      )

    cover_path = Path.join(project.path, output) |> Path.expand()
    {project.app, [cover_path], [compile_path]}
  end

  defp cover_compile(compile_paths) do
    _ = :cover.stop()
    {:ok, pid} = :cover.start()

    for compile_path <- compile_paths do
      case :cover.compile_beam(beams(compile_path)) do
        results when is_list(results) ->
          :ok

        {:error, reason} ->
          Mix.raise(
            "Failed to cover compile directory #{inspect(Path.relative_to_cwd(compile_path))} " <>
              "with reason: #{inspect(reason)}"
          )
      end
    end

    pid
  end

  # Pick beams from the compile_path but if by any chance it is a protocol,
  # gets its path from the code server (which will most likely point to
  # the consolidation directory as long as it is enabled).
  #
  # This is copied from the default elixir test.coverage implementation
  defp beams(dir) do
    consolidation_dir = Mix.Project.consolidation_path()

    consolidated =
      case File.ls(consolidation_dir) do
        {:ok, files} -> files
        _ -> []
      end

    for file <- File.ls!(dir), Path.extname(file) == ".beam" do
      with true <- file in consolidated,
           [_ | _] = path <- :code.which(file |> Path.rootname() |> String.to_atom()) do
        path
      else
        _ -> String.to_charlist(Path.join(dir, file))
      end
    end
  end

  defp import_cover_results(app, cover_paths) do
    case Enum.flat_map(cover_paths, &Path.wildcard(Path.join(&1, "#{app}*.coverdata"))) do
      [] ->
        Mix.shell().error(
          "#{app} - could not find .coverdata file in any of the paths: " <>
            Enum.join(cover_paths, ", ")
        )

      entries ->
        for entry <- entries do
          Mix.shell().info("#{app} - importing cover results: #{entry}")
          :ok = :cover.import(String.to_charlist(entry))
        end
    end
  end

  defp calculate_coverage(workspace_path) do
    :cover.modules()
    |> Enum.sort()
    |> Enum.map(&calculate_module_coverage(&1, workspace_path))
  end

  defp calculate_module_coverage(module, workspace_path) do
    module_path = module.module_info(:compile)[:source]

    path =
      module_path
      |> to_string()
      |> Path.relative_to(workspace_path)

    # Ignore compiled modules with path:
    # - not relative to the app (e.g. generated by umbrella dependencies)
    # - ignored by configuration
    case Path.type(path) do
      :relative ->
        {:ok, function_data} = :cover.analyze(module, :calls, :function)
        {:ok, line_data} = :cover.analyze(module, :calls, :line)
        {module, function_data, line_data}

      # ignore non relative paths to the workspace
      _other ->
        nil
    end
  end
end
