defmodule Mix.Tasks.Workspace.Test.Coverage do
  @options_schema Workspace.Cli.options([
                    :workspace_path,
                    :config_path,
                    :project,
                    :affected,
                    :ignore,
                    :verbose
                  ])

  @shortdoc "Runs test coverage on the workspace"

  @moduledoc """
  Run test coverage on the workspace

  You can use it to generate test coverage for one or more projects of the
  workspace. It will take care of finding the `coveradata` files, fixing the
  absolute paths with respect to the workspace root and formatting the
  resutls

      $ mix workspace.test.coverage

  ## Exporting coverage

  This task assumes that `mix test` has been executed with `--cover` and the
  `:export` option under `:test_coverage` set. 

  ## Command line options

  #{CliOpts.docs(@options_schema)}
  """
  use Mix.Task

  @impl true
  def run(args) do
    {:ok, opts} = CliOpts.parse(args, @options_schema)
    %{parsed: opts, args: _args, extra: _extra, invalid: []} = opts

    workspace_path = Keyword.get(opts, :workspace_path, File.cwd!())
    config_path = Keyword.fetch!(opts, :config_path)

    config = Workspace.config(Path.join(workspace_path, config_path))
    workspace = Workspace.new(workspace_path, config)

    paths =
      workspace.projects
      |> Workspace.Cli.filter_projects(opts)
      |> Enum.filter(fn project -> !project.skip end)
      |> Enum.map(&cover_compile_paths/1)
      |> IO.inspect()

    compile_paths = Enum.map(paths, &elem(&1, 2)) |> List.flatten()

    pid = cover_compile(compile_paths)

    Enum.each(paths, fn {app, cover_paths, _compile_paths} -> import_cover_results(app, cover_paths)end)

    lcov =
      calculate_coverage(workspace_path)
      |> List.flatten()

    # TODO: set the file from cli args
    File.write!("coverage.lcov", lcov, [:write])
  end

  defp cover_compile_paths(project) do
    test_coverage = project.config[:test_coverage] || []
    output = Keyword.get(test_coverage, :output, "cover")

    compile_path =
      Mix.Project.in_project(
        project.app,
        project.path,
        fn _mixfile ->
          Mix.Project.compile_path()
        end
      )

    cover_path = Path.join(project.path, output) |> Path.expand()
    {project.app, [cover_path], [compile_path]}
  end

  defp cover_compile(compile_paths) do
    _ = :cover.stop()
    {:ok, pid} = :cover.start()

    for compile_path <- compile_paths do
      case :cover.compile_beam(beams(compile_path)) do
        results when is_list(results) ->
          :ok

        {:error, reason} ->
          Mix.raise(
            "Failed to cover compile directory #{inspect(Path.relative_to_cwd(compile_path))} " <>
              "with reason: #{inspect(reason)}"
          )
      end
    end

    pid
  end

  # Pick beams from the compile_path but if by any chance it is a protocol,
  # gets its path from the code server (which will most likely point to
  # the consolidation directory as long as it is enabled).
  #
  # This is copied from the default elixir test.coverage implementation
  defp beams(dir) do
    consolidation_dir = Mix.Project.consolidation_path()

    consolidated =
      case File.ls(consolidation_dir) do
        {:ok, files} -> files
        _ -> []
      end

    for file <- File.ls!(dir), Path.extname(file) == ".beam" do
      with true <- file in consolidated,
           [_ | _] = path <- :code.which(file |> Path.rootname() |> String.to_atom()) do
        path
      else
        _ -> String.to_charlist(Path.join(dir, file))
      end
    end
  end

  defp import_cover_results(app, cover_paths) do
    case Enum.flat_map(cover_paths, &Path.wildcard(Path.join(&1, "*.coverdata"))) do
      [] ->
        Mix.shell().error(
          "#{app} - could not find .coverdata file in any of the paths: " <>
            Enum.join(cover_paths, ", ")
        )

      entries ->
        for entry <- entries do
          Mix.shell().info("#{app} - importing cover results: #{entry}")
          :ok = :cover.import(String.to_charlist(entry))
        end
    end
  end

  defp calculate_coverage(workspace_path) do
    :cover.modules()
    |> Enum.sort()
    |> Enum.map(&(calculate_module_coverage(&1, workspace_path)))
  end

  defp calculate_module_coverage(module, workspace_path) do
    module_path = module.module_info(:compile)[:source]
    IO.inspect(module_path, label: "module_path")
    path =
      module.module_info(:compile)[:source]
      |> to_string()
      |> Path.relative_to(workspace_path)
    IO.inspect(path, label: "relative_path")

    # Ignore compiled modules with path:
    # - not relative to the app (e.g. generated by umbrella dependencies)
    # - ignored by configuration
    case Path.type(path) do
      :relative ->
        calculate_and_format_coverage(module, path)

      # ignore non relative paths to the workspace
      _other ->
        []
    end
  end

  defp calculate_and_format_coverage(module, path) do
    {:ok, function_data} = :cover.analyse(module, :calls, :function)
    {total_functions, covered_functions, function_data} = calculate_function_coverage(module, function_data)

    {:ok, lines_data} = :cover.analyse(module, :calls, :line)
    {total_lines, covered_lines, lines_data} = calculate_line_coverage(module, lines_data)
    
    format_lcov(module, path, function_data, total_functions, covered_functions, lines_data, total_lines, covered_lines)
  end

  defp calculate_function_coverage(module, results) do
    function_data =
      results
      # TODO: verify that this filtering is correct - check on a big codebase
      # it should always return the same counts
      |> Enum.filter(fn {{mod, _function, _arity}, _count} -> mod == module end)
      |> Enum.map(fn {{_module, function, arity}, count} -> {{function, arity}, count} end)
      |> Enum.filter(fn {{function, _arity}, _count} -> function != :__info__ end)
      |> Enum.map(fn {{function, arity}, count} -> {"#{function}/#{arity}", count} end)
      |> Enum.group_by(fn {function, _count} -> function end, fn {_function, count} -> count end)
      |> Enum.map(fn {function, counts} -> {function, Enum.sum(counts)} end)
      |> Enum.sort_by(fn {function, _counts} -> function end)

    total_functions = length(function_data)
    covered_functions = Enum.count(function_data, fn {_function, count} -> count > 0 end)

    {total_functions, covered_functions, function_data}
  end

  defp calculate_line_coverage(module, results) do
    line_data =
      results
      |> Enum.filter(fn {{mod, _line}, _count} -> mod == module end)
      |> Enum.map(fn {{_module, line}, count} -> {line, count} end)
      |> Enum.filter(fn {line, _count} -> line != 0 end)
      |> Enum.group_by(fn {line, _count} -> line end, fn {_line, count} -> count end)
      |> Enum.map(fn {line, counts} -> {line, Enum.sum(counts)} end)
      |> Enum.sort_by(fn {line, _counts} -> line end)

    total_lines = length(line_data)
    uncovered_lines = Enum.count(line_data, fn {_line, count} -> count == 0 end)
    covered_lines = total_lines - uncovered_lines

    {total_lines, covered_lines, line_data}
   end

  defp percentage(0, 0), do: 100.0
  defp percentage(covered, not_covered), do: covered / (covered + not_covered) * 100

  
  @newline "\n"

  defp format_lcov(module, path, functions_coverage, fnf, fnh, lines_coverage, lf, lh) do
    [
      "TN:",
      "#{module}",
      @newline,
      "SF:",
      Path.expand(path),
      @newline,
      function_definitions(functions_coverage),
      instrumented_functions(functions_coverage),
      "FNF:0",
      "#{fnf}",
      @newline,
      "FNH:0",
      "#{fnh}",
      @newline,
      instrumented_lines(lines_coverage),
      "LF:",
      "#{lf}",
      @newline,
      "LH:",
      "#{lh}",
      @newline,
      "end_of_record",
      @newline
    ]
  end

  defp function_definitions(functions_coverage) do
    # TODO: Now we set a dummy function start line, get it from ast
    Enum.map(functions_coverage, fn {function_name, __count} ->
      ["FN:0,", function_name, @newline]
    end)
  end

  # corresponds to the following section of lcov:
  # FNDA:<execution count>,<function name>
  defp instrumented_functions(functions_coverage) do
    Enum.map(functions_coverage, fn {function_name, execution_count} ->
      ["FNDA:", "#{execution_count}", ",", function_name, @newline]
    end)
  end

  # corresponds to the following section of lcov:
  # DA:<line number>,<execution count>[,<checksum>]
  defp instrumented_lines(lines_coverage) do
    Enum.map(lines_coverage, fn {line_number, execution_count} ->
      ["DA:", "#{line_number}", ",", "#{execution_count}", @newline]
    end)
  end
end
